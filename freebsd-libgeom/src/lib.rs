/// Safe bindings to FreeBSD's libgeom
///
/// https://www.freebsd.org/cgi/man.cgi?query=libgeom

use freebsd_libgeom_sys::*;
use lazy_static::lazy_static;
use std::{
    ffi::CStr,
    io::{Error, Result},
    marker::PhantomData,
    mem::MaybeUninit,
    os::raw::c_void,
    ptr::NonNull
};

lazy_static! {
    static ref GEOM_STATS: Result<()> = {
        let r = unsafe { geom_stats_open() };
        if r != 0 {
            Err(Error::last_os_error())
        } else {
            Ok(())
        }
    };
}

/// Describes the stats of a single geom element as part of a [`Snapshot`].
#[derive(Debug, Copy, Clone)]
#[repr(transparent)]
pub struct Devstat<'a>{
    devstat: NonNull<devstat>,
    phantom: PhantomData<&'a devstat>
}

/// Identifies an element in the Geom [`Tree`]
#[derive(Debug, Copy, Clone)]
pub struct Gident<'a>{
    ident: NonNull<gident>,
    phantom: PhantomData<&'a Tree>
}

impl<'a> Gident<'a> {
    pub fn is_consumer(&self) -> bool {
        unsafe{self.ident.as_ref()}.lg_what == gident_ISCONSUMER
    }

    pub fn is_provider(&self) -> bool {
        unsafe{self.ident.as_ref()}.lg_what == gident_ISPROVIDER
    }

    pub fn name(&self) -> &'a CStr {
        unsafe{
            let gprovider = self.ident.as_ref().lg_ptr as *const gprovider;
            assert!(!gprovider.is_null());
            CStr::from_ptr((*gprovider).lg_name)
        }
    }

    pub fn rank(&self) -> u32 {
        unsafe{
            let gprovider = self.ident.as_ref().lg_ptr as *const gprovider;
            assert!(!gprovider.is_null());
            let geom = (*gprovider).lg_geom;
            assert!(!geom.is_null());
            (*geom).lg_rank
        }
    }
}

/// A device identifier as contained in `struct devstat`.
#[derive(Debug, Copy, Clone)]
pub struct Id<'a> {
    id: *const c_void,
    phantom: PhantomData<&'a Devstat<'a>>
}

/// A geom statistics snapshot.
///
/// This implements `Iterator`, with an extra `reset` method that can reset the
/// internal pointer back to the beginning.
// FreeBSD BUG: geom_stats_snapshot_get should return an opaque pointer instead
// of a void*, for better type safety.
pub struct Snapshot(NonNull<c_void>);

impl Snapshot {
    /// Acquires a new snapshot of the raw data from the kernel.
    ///
    /// Is not guaranteed to be completely atomic and consistent.
    pub fn new() -> Result<Self> {
        GEOM_STATS.as_ref().unwrap();
        let raw = unsafe { geom_stats_snapshot_get() };
        NonNull::new(raw)
            .map(Snapshot)
            .ok_or_else(Error::last_os_error)
    }

    /// Reset the state of the internal iterator back to the beginning
    pub fn reset(&mut self) {
        unsafe {geom_stats_snapshot_reset(self.0.as_mut())}
    }

    /// Accessor for the embedded timestamp generated by [`Snapshot::new`].
    // FreeBSD BUG: geom_stats_snapshot_timestamp should take a const pointer,
    // not a mut one.
    pub fn timestamp(&mut self) -> Timespec {
        let inner = unsafe {
            let mut ts = MaybeUninit::uninit();
            geom_stats_snapshot_timestamp(self.0.as_mut(), ts.as_mut_ptr());
            ts.assume_init()
        };
        Timespec(inner)
    }
}

impl Drop for Snapshot {
    fn drop(&mut self) {
        unsafe { geom_stats_snapshot_free(self.0.as_mut()) };
    }
}

impl<'a> Iterator for &'a mut Snapshot {
    type Item = Devstat<'a>;

    fn next(&mut self) -> Option<Self::Item> {
        let raw = unsafe {geom_stats_snapshot_next(self.0.as_mut()) };
        NonNull::new(raw)
            .map(|devstat| Devstat{devstat, phantom: PhantomData})
    }
}

/// Return type of [`Snapshot::timestamp`].  It's the familiar C `timespec`.
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
// The wrapper is necessary just to be proper CamelCase
pub struct Timespec(freebsd_libgeom_sys::timespec);

/// Describes the entire Geom heirarchy.
#[derive(Debug)]
#[repr(transparent)]
pub struct Tree(gmesh);

impl Tree {
    // FreeBSD BUG: geom_lookupid takes a mutable pointer when it could be const
    pub fn lookup<'a>(&'a mut self, id: Id) -> Option<Gident<'a>> {
        let raw = unsafe {
            geom_lookupid(&mut self.0, id.id)
        };
        NonNull::new(raw)
            .map(|ident| Gident{ident, phantom: PhantomData})
    }

    /// Construct a new `Tree` representing all available geom providers
    pub fn new() -> Result<Self> {
        let (inner, r) = unsafe {
            let mut inner = MaybeUninit::<gmesh>::uninit();
            let r = geom_gettree(inner.as_mut_ptr());
            (inner, r)
        };
        if r != 0 {
            Err(Error::last_os_error())
        } else {
            Ok(Tree(unsafe{inner.assume_init()}))
        }
    }
}

impl Drop for Tree {
    fn drop(&mut self) {
        unsafe { geom_deletetree(&mut self.0) };
    }
}
